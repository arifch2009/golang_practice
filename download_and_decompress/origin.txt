

    Processing
    p5.js
    Processing.py
    Processing for Android

    Processing Foundation

Cover

Download
Donate

Exhibition

Reference
Libraries
Tools
Environment

Tutorials
Examples
Books
Handbook

Overview
People

Shop

»Forum
»GitHub
»Issues
»Wiki
»FAQ
»Twitter
»Facebook
»Medium

This tutorial is from the book Learning Processing, 2nd Edition by Daniel Shiffman, published by Morgan Kaufmann, © 2015 Elsevier Inc. All rights reserved. If you see any errors or have comments, please let us know.
Data
Daniel Shiffman

This tutorial picks up where the Strings and Drawing Text tutorial leaves off and examines how to use String objects as the basis for reading and writing data. We'll start by learning more sophisticated methods for manipulating Strings, searching in them, chopping them up, and joining them together. Afterwards, we'll see how these skills allow us to use input from data sources, such as text files, web pages, xml feeds, and 3rd party APIs and take a step into the world of data visualization.
Manipulating Strings

In Strings and Drawing Text, we touched on a few of the basic functions available in the Java String, such as charAt(), toUpperCase(), equals(), and length(). These functions are documented on the Processing reference page for Strings. Nevertheless, in order to perform some more advanced data parsing techniques, we'll need to explore some additional String manipulation functions documented in the Java API.

Let's take a closer look at the following two String functions: indexOf() and substring().

indexOf() locates a sequence of characters within a string. It takes one argument — a search string — and returns a numeric value that corresponds to the first occurrence of the search string inside of the String object being searched.

String search = "def";
String toBeSearched = "abcdefghi";
int index = toBeSearched.indexOf(search);  // The value of index in this example is 3.

Strings are just like arrays, in that the first character is index number zero and the last character is the length of the string minus one. If the search string cannot be found, indexOf() returns -1. This is a good choice because -1 is not a legitimate index value in the string itself, and therefore can indicate "not found." There are no negative indices in a string of characters or in an array.

After finding a search phrase within a string, we might want to separate out part of the string, saving it in a different variable. A part of a string is known as a substring and substrings are made with the substring() function which takes two arguments, a start index and an end index. substring() returns the substring in between the two indices.

String alphabet = "abcdefghi";
String sub = alphabet.substring(3, 6); // The String sub is now "def".

Note that the substring begins at the specified start index (the first argument) and extends to the character at end index (the second argument) minus one. I know, I know. Wouldn’t it have been easier to just take the substring from the start index all the way to the end index? While this might initially seem true, it’s actually quite convenient to stop at end index minus one. For example, if you ever want to make a substring that extends to the end of a string, you can simply go all the way to thestring.length(). In addition, with end index minus one marking the end, the length of the substring is easily calculated as end index minus begin index.

Splitting and Joining Strings

In Strings and Drawing Text, we saw how strings can be joined together (referred to as "concatenation") using the "+" operator. Let's review with a example that uses concatenation to get user input from a keyboard.

PFont f;
		
// Variable to store text currently being typed
String typing = "";
// Variable to store saved text when return is hit
String saved = "";
		
void setup() {  
  size(300, 200);  
  f = createFont("Arial", 16);
}
		
void draw() {  
  background(255);  
  int indent = 25;  

  // Set the font and fill for text  
  textFont(f);  
  fill(0);  

  // Display everything  
  text("Click in this sketch and type. \nHit return to save what you typed.", indent, 40);  
  text(typing, indent, 90);  
  text(saved, indent, 130);
}
		
void keyPressed() {  
  // If the return key is pressed, save the String and clear it  
  if (key == '\n') {    
    saved = typing;    
    typing = "";  
    // Otherwise, concatenate the String  
  } else {    
    typing = typing + key;   
  }
}

Processing has two additional functions that make joining strings (or the reverse, splitting them up) easy. In sketches that involve parsing data from a file or the web, you might get hold of that data in the form of an array of strings or as one long string. Depending on what you want to accomplish, it’s useful to know how to switch between these two modes of storage. This is where these two new functions, split() and join(), will come in handy.

"one long string or array of strings" ←→ {"one", "long", "string", "or" ,"array", "of", "strings"}

Let’s take a look at the split() function. split() separates a longer string into an array of strings, based on a split character known as the delimiter. It takes two arguments, the String object to be split and the delimiter. (The delimiter can be a single character or a string.) In the code below, the period is not set as a delimiter and therefore will be included in the last string in the array: “dog.” Note how printArray() can be used to print the contents of an array and their corresponding indices to the message console.

// Splitting a string based on spaces
String spaceswords = "The quick brown fox jumps over the lazy dog.";
String[] list = split(spaceswords, " ");
printArray(list);

Here is an example using a comma as the delimiter (this time passing in a single character: ','.)

// Splitting a string based on commas
String commaswords = "The,quick,brown,fox,jumps,over,the,lazy,dog.";
String[] list = split(commaswords, ",");
printArray(list);

If you want to use more than one delimiter to split up a text, you must use the Processing function splitTokens(). splitTokens() works identically as split() with one exception: any character that appears in the passed string qualifies as a delimiter.) In the code below, the period is specified as a delimiter and therefore will not be included in the last string in the array: “dog”.

// Splitting a String based on multiple delimiters
String stuff = "hats & apples, cars + phones % elephants dog."; 
String[] list = splitTokens(stuff, " &,+." );
printArray(list);

If you are splitting numbers in a string, the resulting array can be converted into an integer array with Processing’s int() function. Numbers in a string are not numbers and cannot be used in mathematical operations unless you convert them first.

// Calculate sum of a list of numbers in a String
String numbers = "8,67,5,309";
// Converting the String array to an int array
int[] list = int(split(numbers, ','));
int sum = 0;
for (int i = 0; i<list.length; i++ ) {
  sum = sum + list[i];
}
println(sum);

The reverse of split() is join(). join() takes an array of strings and joins them together into one long String object. The join() function also takes two arguments, the array to be joined and a separator. The separator can either be a single character or a string of characters.

Consider the following array:

String[] lines = {"It", "was", "a", "dark", "and", "stormy", "night."};

Using the “+” operator along with a for loop, you can join a string together as follows:

// Manual Concatenation
String onelongstring = "";
for (int i = 0; i < lines.length; i++) {
   onelongstring = onelongstring + lines[i] + " ";
}

The join() function, however, allows you to bypass this process, achieving the same result in only one line of code.

// Using Processing's join()
String onelongstring = join(lines, " ");

Dealing with Data

Data can come from many different places: websites, news feeds, spreadsheets, databases, and so on. Let's say you've decided to make a map of the world's flowers. After searching online you might find a PDF version of a flower encyclopedia, or a spreadsheet of flower genera, or a JSON feed of flower data, or a REST API that provides geolocated lat/lon coordinates, or some web page someone put together with beautiful flower photos, and so on and so forth. The question inevitably arises: “I found all this data; which should I use, and how do I get it into Processing?”

If you are really lucky, you might find a Processing library that hands data to you directly with code. Maybe the answer is to just download this library and write some code like:

import flowers.*;

void setup() {
  FlowerDatabase fdb = new FlowerDatabase();
  Flower sunflower = fdb.findFlower("sunflower");
  float h = sunflower.getAverageHeight();
}  

In this case, someone else has done all the work for you. They've gathered data about flowers and built a Processing library with a set of functions that hands you the data in an easy-to-understand format. This library, sadly, does not exist (not yet), but there are some that do. For example, YahooWeather is a library by Marcel Schwittlick that grabs weather data from Yahoo for you, allowing you to write code like weather.getWindSpeed() or weather.getSunrise() and more. There is still plenty of work to do in the case of using a library.

Let's take another scenario. Say you’re looking to build a visualization of Major League Baseball statistics. You can't find a Processing library to give you the data but you do see everything you’re looking for at mlb.com. If the data is online and your web browser can show it, shouldn't you be able to get the data in Processing? Passing data from one application (like a web application) to another (say, your Processing sketch) is something that comes up again and again in software engineering. A means for doing this is an API or “application programming interface”: a means by which two computer programs can talk to each other. Now that you know this, you might decide to search online for “MLB API”. Unfortunately, mlb.com does not provide its data via an API. In this case you would have to load the raw source of the website itself and manually search for the data you’re looking for. While possible, this solution is much less desirable given the considerable time required to read through the HTML source as well as program algorithms for parsing it.

Each means of getting data comes with its own set of challenges. The ease of using a Processing library is dependent on the existence of clear documentation and examples. But in just about all cases, if you can find your data in a format designed for a computer (spreadsheets, XML, JSON, etc.), you'll be able to save some time in the day for a nice walk outside.

One other note worth a mention about working with data. When developing an application that involves a data source, such as a data visualization, it’s sometimes useful to develop with “dummy” or “fake” data. You don't want to be debugging your data retrieval process at the same time as solving problems related to algorithms for drawing. In keeping with my one-step-at-a-time mantra, once the meat of the program is completed with dummy data, you can then focus solely on how to retrieve the actual data from the real source. You can always use random or hard-coded numbers into your code when you’re experimenting with a visual idea and connect the real data later.
Working with Text Files

Let's begin by working with the simplest means of data retrieval: reading from a text file. Text files can be used as a very simple database (you could store settings for a program, a list of high scores, numbers for a graph, etc.) or to simulate a more complex data source.

In order to create a text file, you can use any simple text editor. Windows Notepad or Mac OS X TextEdit will do; just make sure you format the file as “plain text.” It is also advisable to name the text files with the “.txt” extension, to avoid any confusion. And just as with image files, these text files should be placed in the sketch’s “data” directory in order for them to be recognized by the Processing sketch.

Once the text file is in place, Processing’s loadStrings() function is used to read the content of the file into a String array. The individual lines of text in the file each become an individual element in the array.

// This code will print all the lines from the source text file.
String[] lines = loadStrings("file.txt");
println("There are " + lines.length + " lines.");
printArray(lines);

To run the code, create a text file called “file.txt,” type a bunch of lines in that file, and place it in your sketch’s data directory.

Text from a file can be used to generate a simple visualization. Take the following data file.



The results of visualizing this data are shown below.

Graphing Comma-Separated Numbers from a Text File

int[] data;

void setup() {
  size(200, 200);
  // Load text file as a String
  String[] stuff = loadStrings("data.csv");
  // Convert string into an array of integers using ',' as a delimiter
  data = int(split(stuff[0], ','));
}

void draw() {
  background(255);
  stroke(0);
  for (int i = 0; i<data.length; i++) { 
  	// Use array of ints to set the color and height of each rectangle.
    rect(i*20, 0, 20, data[i]);
  }
  noLoop();
}

Looking at how to parse a csv file with split() was a nice learning exercise. In truth, dealing with csv files (which can easily be generated from spreadsheet software such as Google docs) is such a common activity that Processing has an entire built-in class called Table to handle the parsing for you.

Tabular Data

A table consists of data arranged as a set of rows and columns, also called “tabular data.” If you've ever used a spreadsheet, this is tabular data. Processing's loadTable() function takes comma-separated (csv) or tab-separated (tsv) values and automatically places the contents into a Table object storing the data in columns and rows. This is a great deal more convenient than struggling to manually parse large data files with split(). It works as follows. Let's say you have a data file that looks like:

Instead of saying:

String[] stuff = loadStrings("data.csv");

We can now say:

Table table = loadTable("data.csv");

Now I've missed an important detail. Take a look again at the data.csv text file above. Notice how the first line of text is not the data itself, but rather a header row. This row includes labels that describe the data included in each subsequent row. The good news is that Processing can automatically interpret and store the headers for you, if you pass in the option "header" when loading the table. (In addition to "header", there are other options you can specify. For example, if your file is called data.txt but is comma separated data you can pass in the option "csv". If it also has a header row, then you can specifiy both options like so: "header,csv"). A full list of options can be found on the loadTable() documentation page.

Table table = loadTable("data.csv", "header");

Now that the table is loaded, I can show how you grab individual pieces of data or iterate over the entire table. Let's look at the data visualized as a grid.

In the above grid you can see that the data is organized in terms of rows and columns. One way to access the data, therefore, would be to request a value by its numeric row and column location (with zero being the first row or first column). This is similar to accessing a pixel color at a given (x,y) location, though in this case the y position (row) comes first. The following code requests a piece of data at a given (row, column) location.

int val1 = table.getInt(2, 1);      // val now has the value 235

float val2 = table.getFloat(3, 2);  // val2 now has the value 44.758068

String s = table.getString(0, 3);   // s now has the value “Happy”

While the numeric index is sometimes useful, it’s generally going to be more convenient to access each piece of data by the column name. For example, I could pull out a specific row from the Table.

TableRow row = table.getRow(2); // Gets the third row (index 2)

Note in the above line of code that a Table object refers to the entire table of data while a TableRow object handles an individual row of data within the Table.

Once I have the TableRow object, I can ask for data from some or all of the columns.

int x = row.getInt("x"); // 	    // x has the value 273

int y = row.getInt("y");            // y has the value 235

float d = row.getFloat("diameter"); // d has the value 61.14072

String s = row.getString("name");   // s has the value “Joyous”

The method getRow() returns a single row from the table. If you want to grab all the rows and iterate over them you can do so in a loop with a counter accessing each row one at a time. The total number of available rows can be retrieved with getRowCount().

for (int i = 0; i<table.getRowCount(); i++) {

  // Access each row of the table one at a time, in a loop.
  TableRow row = table.getRow(i);
  float x = row.getFloat("x");
  float y = row.getFloat("y");
  float d = row.getFloat("diameter");
  String n = row.getString("name");

  // Do something with the data of each row

}

If you want to search for a select number of rows within the table, you can do so with findRows() and matchRows().

In addition to being read, Table objects can be altered or created on the fly while a sketch is running. Cell values can be adjusted, rows can be removed, and new rows can be added. For example, to set new values in a cell there are functions setInt(), setFloat(), and setString().

row.setInt("x", mouseX); // Update the value of column "x" to mouseX in a given TableRow.

To add a new row to a Table, simply call the method addRow() and set the values of each column.

//Create a new row.
TableRow row = table.addRow();

//Set the values of all columns in that row.
row.setFloat("x", mouseX);
row.setFloat("y", mouseY);
row.setFloat("diameter", random(40, 80));
row.setString("name", "new label");

To delete a row, simply call the method removeRow() and pass in the numeric index of the row you would like removed. For example, the following code removes the first row whenever the size of the table is greater than ten rows.

// If the table has more than 10 rows
if (table.getRowCount()>10) {

//Delete the first row (index 0).
  table.removeRow(0);
}

The following example puts all of the above code together. Notice how each row of the table contains the data for a Bubble object.

Loading and Saving Tabular Data

// The data from the Table object will fill the array of Bubble objects
Table table;
Bubble[] bubbles;

void setup() {
  size(480, 360);
  loadData();
}

void draw() {
  background(255);
  // Display all bubbles
  for (int i = 0; i<bubbles.length; i++) {
    bubbles[i].display();
  }
}

void loadData() {
  // "header" indicates the file has header row. The size of the array 
  // is then determined by the number of rows in the table. 
  table = loadTable("data.csv", "header");
  bubbles = new Bubble[table.getRowCount()];


  for (int i = 0; i<table.getRowCount(); i++) {
    // Iterate over all the rows in a table.
    TableRow row = table.getRow(i);

	
    // Access the fields via their column name (or index).
    float x = row.getFloat("x");
    float y = row.getFloat("y");
    float d = row.getFloat("diameter");
    String n = row.getString("name");
    // Make a Bubble object out of the data from each row.
    bubbles[i] = new Bubble(x, y, d, n);
  }
}


void mousePressed() {
  // When the mouse is pressed, create a new row and set the values for each column of that row.
  TableRow row = table.addRow();
  row.setFloat("x", mouseX);
  row.setFloat("y", mouseY);
  row.setFloat("diameter", random(40, 80));
  row.setString("name", "Blah");

  // If the table has more than 10 rows, delete the oldest row.
  if (table.getRowCount()>10) {
    table.removeRow(0);
  }

  // This writes the table back to the original CSV file
  // and reloads the file so that what's drawn matches.
  saveTable(table, "data/data.csv");
  loadData();
}

// This simple Bubble class draws a circle to the window 
// and displays a text label when the mouse hovers.
class Bubble {
  float x, y;
  float diameter;
  String name;
  
  boolean over = false;
  
  // Create the Bubble
  Bubble(float tempX, float tempY, float tempD, String s) {
    x = tempX;
    y = tempY;
    diameter = tempD;
    name = s;
  }
  
  // Checking if mouse is over the bubble
  void rollover(float px, float py) {
    float d = dist(px, py, x, y);
    if (d<diameter/2) {
      over = true; 
    } else {
      over = false;
    }
  }
  
  // Display the Bubble
  void display() {
    stroke(0);
    strokeWeight(2);
    noFill();
    ellipse(x, y, diameter, diameter);
    if (over) {
      fill(0);
      textAlign(CENTER);
      text(name, x, y+diameter/2+20);
    }
  }
}

Here, the distance between a given point and a circle's center is compared to that circle's radius as depicted:

In the code below, the function returns a boolean value (true or false) depending on whether the point (mx,my) is inside the circle. Notice how radius is equal to half the diameter.

boolean rollover(int mx, int my) {
  if (dist(mx, my, x, y)<diameter/2) {
    return true;
  } else {
    return false;
  }
}

Data that is not in a Standardized Format

What if your data is not in a standard format like a table, how do you deal with it then? One of the nice features about loadStrings() is that in addition to pulling text from a file, you can also grab a URL. For example:

String[] lines = loadStrings("http://www.yahoo.com");

When you send a URL path into loadStrings(), you get back the raw HTML (Hypertext Markup Language) source of the requested web page. It’s the same stuff that appears upon selecting “View Source” from a browser’s menu options. You don’t need to be an HTML expert to follow this section, but if you are not familiar at all with HTML, you might want to read http://en.wikipedia.org/wiki/HTML.

Unlike with the comma-delimited data from a text file that was specially formatted for use in a Processing sketch, it’s not practical to have the resulting raw HTML stored in an array of strings (each element representing one line from the source). Converting the array into one long string can make things a bit simpler. As you saw earlier in the chapter, this can be achieved using join().

String onelongstring = join(lines, " ");

When pulling raw HTML from a web page, it’s likely you do not want all of the source, but just a small piece of it. Perhaps you’re looking for weather information, a stock quote, or a news headline. You can take advantage of the text manipulation functions you learned — indexOf(), substring(), and length() — to find pieces of data within a large block of text. Take, for example, the following String object:

String stuff = "Number of apples:62. Boy, do I like apples or what!";

Let’s say I want to pull out the number of apples from the above text. My algorithm would be as follows:

    Find the end of the substring “apples:” Call it start.

    Find the first period after “apples:” Call it end.

    Make a substring of the characters between start and end.

    Convert the string to a number (if I want to use it as such).

In code, this looks like:

int start      = stuff.indexOf("apples:" ) + 8;  // STEP 1 
// The index where a string ends can be found by 
// searching for that string and adding its length (here, 8).
int end        = stuff.indexOf(".", start);      // STEP 2
String apples  = stuff.substring(start, end);    // STEP 3
int apple_no   = int(apples);                    // STEP 4

The above code will do the trick, but I should be a bit more careful to make sure I don’t run into any errors if I do not find the string I am searching for. I can add some error checking and generalize the code into a function:

// A function that returns a substring between two substrings. 
// If the beginning of end "tag" is not found, the function returns an empty string.
String giveMeTextBetween(String s, String startTag, String endTag) {
  // Find the index of the beginning tag
  int startIndex = s.indexOf(startTag);
  // If I don't find anything
  if (startIndex == -1) {
    return "";
  }
  // Move to the end of the beginning tag
  startIndex += startTag.length();

  // Find the index of the end tag
  int endIndex = s.indexOf(endTag, startIndex);
  
  // If I don't find the end tag,
  if (endIndex == -1) {
    return "";
  }
  // Return the text in between
  return s.substring(startIndex, endIndex);
}

With this technique, you are ready to connect to a website from within Processing and grab data to use in your sketches. For example, you could read the HTML source from nytimes.com and look for today’s headlines, search finance.yahoo.com for stock quotes, count how many times the word “flower” appears on your favorite blog, and so on. However, HTML is an ugly, scary place with inconsistently formatted pages that are difficult to reverse engineer and parse effectively. Not to mention the fact that companies change the source code of web pages rather often, so any example that I might make while I am writing this paragraph might break by the time you read this paragraph.

For grabbing data from the web, an XML (Extensible Markup Language) or JSON (JavaScript Object Notation) feed will prove to be more reliable and easier to parse. Unlike HTML (which is designed to make content viewable by a human’s eyes) XML and JSON are designed to make content viewable by a computer and facilitate the sharing of data across different systems. Most data (news, weather, and more) is available this way, and I will look at examples in #beginner_xml and #JSON. Though much less desirable, manual HTML parsing is still useful for a couple reasons. First, it never hurts to practice text manipulation techniques that reinforce key programming concepts. But more importantly, sometimes there is data you really want that is not available in an API format, and the only way to get it is with such a technique. (I should also mention that regular expressions, an incredibly powerful techinque in text pattern matching, could also be employed here. As much as I love regex, it’s unfortunately beyond the scope of this tutorial.)

An example of data only available as HTML is the Internet Movie Database. IMDb contains information about movies sorted by year, genre, ratings, etc. For each movie, you can find the cast and crew list, a plot summary, running time, a movie poster image, the list goes on. However, IMDb has no API and does not provide its data as XML or JSON. Pulling the data into Processing therefore requires a bit of detective work. Let's look at the page for the Shaun the Sheep Movie

Looking in the HTML source from the above URL, I find a giant mess of markup.

It’s up to me to pore through the raw source and find the data I am looking for. Let's say I want to know the running time of the movie and grab the movie poster image. After some digging, I find that the movie is 139 minutes long as listed in the following HTML.

<div class="txt-block">
  <h4 class="inline">Runtime:</h4> 
    <time itemprop="duration" datetime="PT139M">139 min</time>
</div>

For any given movie, the running time itself will be variable, but the HTML structure of the page will stay the same. I can therefore deduce that running time will always appear in between:

<time itemprop="duration" datetime="PT139M">

and:

</time>

Knowing where the data starts and ends, I can use giveMeTextBetween() to pull out the running time. A quote in Java marks the beginning or end of a string. So how do you include an actual quote in a String object? The answer is via an “escape” sequence. A quote can be included using a backward slash, followed by a quote. For example: String q = "This String has a quote \"in it";

String url = "http://www.imdb.com/title/tt0058331";
String[] lines = loadStrings(url);
// Get rid of the array in order to search the whole page
String html = join(lines, " ");

// Searching for running time
String start = ""; 

String end = "";
String runningtime = giveMeTextBetween(html, start, end);
println(runningtime);

The following code retrieves both the running time and movie poster iamge from IMDb and displays it onscreen.

Parsing IMDb Manually

String runningtime;
PImage poster;

void setup() {
  size(300, 350);
  loadData();
}

void draw() {
  // Display all the stuff I want to display
  background(255);
  image(poster, 10, 10, 164, 250);
  fill(0);
  text("Shaun the Sheep", 10, 300);
  text(runningtime, 10, 320);
}

void loadData() {
  String url = "http://www.imdb.com/title/tt2872750/";

  // Get the raw HTML source into an array of strings (each line is one element in the array).
  // The next step is to turn array into one long string with join().
  String[] lines = loadStrings(url);
  String html = join(lines, "");

  String start = "";
  String end = "";
  runningtime = giveMeTextBetween(html, start, end);Searching for running time.

  start = "";
  // Search for the URL of the poster image.
  String imgUrl = giveMeTextBetween(html, start, end);
  // Now, load that image!
  poster = loadImage(imgUrl);
}

String giveMeTextBetween(String s, String before, String after) {

  // This function returns a substring between two substrings (before and after).
  //  If it can’t find anything it returns an empty string.
  String found = "";

  // Find the index of before
  int start = s.indexOf(before);     
  if (start == -1) {
    return "";                       
  }    

  // Move to the end of the beginning tag
  // and find the index of the "after" String      
  start += before.length();    
  int end = s.indexOf(after, start); 
  if (end == -1) {
    return "";                       
  }

  // Return the text in between
  return s.substring(start, end); 
}

Text Analysis

Loading text from a URL need not only be an exercise in parsing out small bits of information. It’s possible with Processing to analyze large amounts of text found on the web from news feeds, articles, and speeches, to entire books. A nice source is Project Gutenberg which makes available thousands of public domain texts. Algorithms for analyzing text merits an entire book itself, but let’s look at some basic techniques.

A text concordance is an alphabetical list of words that appear in a book or body of text along with contextual information. A sophisticated concordance might keep a list of where each word appears (like an index) as well as which words appear next to which other words. In this case, I'm going to create a simple concordance, one that simply stores a list of words and their corresponding counts, i.e., how many times they appeared in the text. Concordances can be used for text analysis applications such as spam filtering or sentiment analysis. To accomplish this task, I am going to use the Processing built-in class IntDict.

As you learned earlier, an array is an ordered list of variables. Each element of the array is numbered and be accessed by its numeric index.

However, what if instead of numbering the elements of an array you could name them? This element is named “Sue,” this one “Bob,” this one “Jane,” and so on and so forth. In programming, this kind of data structure is often referred to as an associative array, map, or dictionary. It’s a collection of (key, value) pairs. Imagine you had a dictionary of people's ages. When you look up “Sue” (the key), the definition, or value, is her age, 24.

Associative arrays can be incredibly convenient for various applications. For example, you could keep a list of student IDs (student name, id) or a list of prices (product name, price) in a dictionary. Here a dictionary is the perfect data structure to hold the concordance. Each element of the dictionary is a word paired with its count.

While there are many classes in Java for dealing with advanced data structures like maps, Processing provides you with a set of three built-in dictionary classes that are easy to use: IntDict, FloatDict, and StringDict. In all of these classes, the key is always a string while the value is variable (an integer, floating point number, or String). For the concordance, I'll use an IntDict.

Creating an IntDict is as easy as calling an empty constructor. Let's say you want a dictionary to keep track of an inventory of supplies.

IntDict inventory = new IntDict();

Values can be paired with their keys using the set() method.

// set() assigns an integer to a String.
inventory.set("pencils", 10);
inventory.set("paper clips", 128);
inventory.set("pens, 16");

There are a variety of other methods that can be called to change the value associated with a particular key. For example, if you wanted to add five pencils, you can use add().

inventory.add("pencils", 5);	// The value of “pencils” is now 15.

A particularly convenient method for the concordance example is increment() which adds one to a key's value.

inventory.increment("pens");	// The value of “pencils” is now 16.

To retrieve a value associated with a particular key, the get() method is used.

int num = inventory.get("pencils"); 	// The value of num is 16.

Finally, dictionaries can be sorted by their keys (alphabetical) or values (smallest to largest or the reverse) with the methods sortKeys(), sortKeysReverse(), sortValues(), and sortValuesReverse().

The concordance now becomes a rather simple program to write. All I need to do is load in a text file, chop it into words with splitTokens() and call increment() on an IntDict for every single word found in the text. The following example does precisely this with the entire text of Shakespeare’s play, A Midsummer Night's Dream, displaying a simple graph of the most used words.
Text Concordance Using IntDict

String[] allwords;

// Any punctuation is used as a delimiter.
String delimiters = " ,.?!;:[]";

IntDict concordance;

void setup() {
  size(360, 640);

  // Load A Midsummer Night's Dream into an array of strings
  String url = "http://www.gutenberg.org/cache/epub/1514/pg1514.txt";
  String[] rawtext = loadStrings(url);

  // Join the big array together as one long string
  String everything = join(rawtext, "" );

  // All the lines in A Midsummer Night's Dream are first joined as one big string
  // and then split up into an array of individual words.
  // Note the use of splitTokens() since I am using spaces and punctuation marks as delimiters.
  allwords = splitTokens(everything, delimiters);  


  // Make a new empty dictionary
  concordance = new IntDict();

  for (int i = 0; i<allwords.length; i++) {
    // It's useful to convert each word to lower case so that,
    // for example, “The” and “the” are both counted as the same word.
    String s = allwords[i].toLowerCase();
    // For every single word, increase its count in the dictionary.
    concordance.increment(s);
  }
  
  // Sort the dictionary so that words that appear most often are first.
  concordance.sortValuesReverse();
}

void draw() {
  background(255);

  // Display the text and total times the word appears
  int h = 20;
  // In order to iterate over every word in the dictionary,
  // first ask for an array of all of the keys.
  String[] keys = concordance.keyArray();

  for (int i = 0; i<height/h; i++) {
    // Look at each key one at a time and retrieve its count.
    String word = keys[i]; 
    int count = concordance.get(word);

    fill(51);
    // Displaying a rectangle along with the count as a simple graph.
    rect(0, i*20, count/4, h-4);
    fill(0);
    text(word + ": " + count, 10+count/4, i*h+h/2);
    stroke(0);
  }
}

Processing also includes three classes for lists of numbers and strings: IntList, FloatList, and StringList. In other words, if you just want a list of words (without their counts) you could use a StringList rather than an IntDict.

If your data is available via a standardized format such as XML or JSON, the process of manually searching through text for individual pieces of data is no longer required. XML is designed to facilitate the sharing of data across different systems, and you can retrieve that data using the built-in Processing XML class.

XML organizes information in a tree structure. Let’s imagine a list of students. Each student has an ID number, name, address, email, and telephone number. Each student’s address has a city, state, and zip code. An XML tree for this dataset might look like the following:

The XMl source itself (with two students listed) is:

<?xml version = "1.0" encoding = "UTF-8 "?>
<students>
  <student>
    <id>001</id>
    <name>Daniel Shiffman</name>
    <phone>555-555-5555</phone>
    <email>daniel@shiffman.net</email>
    <address>
      <street>123 Processing Way</street>
      <city>Loops</city>
      <state>New York</state>
      <zip>01234</zip>
    </address>
  </student>
  <student>
    <id>002</id>
    <name>Zoog</name>
    <phone>555-555-5555</phone>
    <email>zoog@planetzoron.uni</email>
    <address>
      <street>45.3 Nebula 5</street>
      <city>Boolean City</city>
      <state>Booles</state>
      <zip>12358</zip>
    </address>
  </student>
</students>

Note the similarities to object-oriented programming. You can think of the XML tree in the following terms. The XML document represents an array of student objects. Each student object has multiple pieces of information, an ID, a name, a phone number, an email address, and a mailing address. The mailing address is also an object that has multiple pieces of data, such as street, city, state, and zip.

Let's look at some data made available from a web service such as Yahoo Weather. Here is the raw XML source. (Note I have edited it slightly for simplification purposes.)

<?xml version="1.0" encoding="UTF-8" standalone="yes" ?>
<rss version="2.0" xmlns:yweather="http://xml.weather.yahoo.com/ns/rss/1.0">
  <channel>
    <item>
      <title>Conditions for New York, NY at 12:49 pm EDT</title>
      <geo:lat>40.67</geo:lat>
      <geo:long>-73.94</geo:long>
      <link>http://us.rd.yahoo.com/dailynews/rss/weather/New_York__NY//link>
      <pubDate>Thu, 24 Jul 2014 12:49 pm EDT</pubDate>
      <yweather:condition text="Partly Cloudy" code="30" temp="76"/>
      <yweather:forecast day="Thu" low="65" high="82" text="Partly Cloudy"/>
    </item>
  </channel>
</rss>

The data is mapped in the tree stucture shown below:

You may be wondering what the top level “RSS” is all about. Yahoo’s XML weather data is provided in RSS format. RSS stands for “Really Simple Syndication” and is a standardized XML format for syndicating web content (such as news articles, etc.). You can read more about RSS on Wikipedia.

Now that you have a handle on the tree structure, let's look at the specifics inside that structure. With the exception of the first line (which simply indicates that this page is XML formatted), this XML document contains a nested list of elements, each with a start tag, that is, <channel>, and an end tag, that is, </channel>. Some of these elements have content between the tags:

<title>Conditions for New York, NY at 12:49 pm EDT</title>

and some have attributes (formatted by Attribute Name equals Attribute Value in quotes):

<yweather:forecast day="Thu" low="65" high="82" text="Partly Cloudy"/>

Using the Processing XML Class

Since the syntax of XML is standardized, I could certainly use split(), indexof(), and substring() to find the pieces I want in the XML source. The point here, however, is that because XML is a standard format, I don't have to do this. Rather, I can use an XML parser. In Processing, XML can be parsed using the built-in Processing class XML.

XML xml = loadXML("http://xml.weather.yahoo.com/forecastrss?p=10003");

Here, instead of loadStrings() or loadTable(), I'm now calling loadXML() and passing in the address (URL or local file) of the XML document. An XML object represents one element of an XML tree. When a document is first loaded, that XML object is always the root element. Referring back to XML tree diagram from Yahoo Weather, I find the current temperature via the following path:

    The root of the tree is RSS.

    RSS has a child named channel.

    Channel has a child named item.

    Item has a child named yweather:condition.

    The temperature is stored in yweather:condition as the attribute temp.

The children of an element are accessed via the getChild() function.

// Accessing the “channel” child element of the root element -->
XML channel = xml.getChild("channel");

The content of an element itself is retrieved with one of the following methods: getContent(), getIntContent(), or getFloatcContent(). getContent() is for generic use and will always give you the content as a String. If you intend to use the content as a number, Processing will convert it for you with either getIntContent() or getFloatcContent(). Attributes can also be read as either numbers — getInt(), getFloat() — or text — getString().

Following steps one through five outlined above through the XML tree, I have:

XML root = loadXML("http://xml.weather.yahoo.com/forecastrss?p=10003"); // Step 1

XML channel     = root.getChild("channel"); // Step 2

XML item        = channel.getChild("item"); // Step 3

XML yweather    = item.getChild("yweather:condition"); // Step 4

int temperature = yweather.getInt("temp"); // Step 5

However, this is a bit long-winded and so can be compressed down into one (or three, as below) lines of code.

XML root = loadXML(http://xml.weather.yahoo.com/forecastrss?p=10003);

XML forecast = 
  root.getChild("channel").getChild("item").getChild("yweather:condition"); // Steps 2-4
int temperature = forecast.getInt("temp");

Finally, the second line of code above can be further condensed to:

XML forecast = xml.getChild("channel/item/yweather:condition"); // Steps 2-4

Following is the above code put together in an example that retrieves weather data for multiple zip codes by parsing Yahoo's XML feed.

Parsing Yahoo Weather XML

int temperature = 0;Temperature is stored as a number and the description of the weather as a string. 
String weather = "";


// The zip code
String zip = "10003";

void setup() {
  size(200, 200);

  // The URL for the XML document
  String url = "http://xml.weather.yahoo.com/forecastrss?p=" + zip;

  // Load the XML document
  XML xml = loadXML(url);

  // Here, I grab the XML element that I want. 
  XML forecast = xml.getChild("channel/item/yweather:forecast");

  // And then I pull the attributes from that XML element.
  temperature = forecast.getInt("high"); 
  weather = forecast.getString("text");
}

void draw() {
  background(255);
  fill(0);

  // Display all the stuff I want to display
  text("Zip code: " + zip, 10, 50);
  text("Today’s high: " + temperature, 10, 70);
  text("Forecast: " + weather, 10, 90);
}

Other useful XML functions are:

    hasChildren() — checks whether or not an element has any children

    getChildren() — returns an array containing all child elements

    getAttributeCount() — counts the specified element's number of attributes

    hasAttribute() — checks whether or not an element has the specified attribute

In this example I'm accessing the child nodes by their name (i.e., "channel," "item,", etc.), however they can also be accessed numerically via an index (starting at zero, same as an array). This is convenient when looping over a list of children, much like I did with tabular data when I iterated over rows in a table.

Earlier, we used a Table to store information related to Bubble objects. XML document can also be used in the same manner. Here is a possible solution for an XML tree of Bubble objects:

<?xml version="1.0" encoding="UTF-8"?>
<bubbles>
  <bubble>
    <position x="160" y="103"/>
    <diameter>43.19838</diameter>
    <label>Happy</label>
  </bubble>
  <bubble>
    <position x="372" y="137"/>
    <diameter>52.42526</diameter>
    <label>Sad</label>
  </bubble>
  <bubble>
    <position x="273" y="235"/>
    <diameter>61.14072</diameter>
    <label>Joyous</label>
  </bubble>
  <bubble>
    <position x="121" y="179"/>
    <diameter>44.758068</diameter>
    <label>Melancholy</label>
  </bubble>
</bubbles>

I can use getChildren() to retrieve the array of <bubble> elements and make a Bubble object from each one. Here is the example which uses the identical Bubble class from earlier (not included below). The new code is in bold.

Using Processing's XML Class

// An Array of Bubble objects
Bubble[] bubbles;
// An XML object
XML xml;

void setup() {
  size(480, 360);
  loadData();
}

void loadData() {
  // Load XML file
  xml = loadXML("data.xml");
  // Get all the child nodes named "bubble"
  XML[] children = xml.getChildren("bubble");

  bubbles = new Bubble[children.length];
  // The size of the Bubble array is determined by the total XML elements named “bubble.”

  for (int i = 0; i < bubbles.length; i++) {
    
    XML positionElement = children[i].getChild("position");
	// The position element has two attributes: “x” and “y”.
	// Attributes can be accessed as an integer or float via getInt() and getFloat().
    float x = positionElement.getInt("x");
    float y = positionElement.getInt("y");
	
    // The diameter is the content of the child named "diameter"
    XML diameterElement = children[i].getChild("diameter");
    float diameter = diameterElement.getFloatContent();
    // Notice, however, with the content of an XML node, 
	// I retrieve via getIntContent() and getFloatContent().

    // The label is the content of the child named "label"
    XML labelElement = children[i].getChild("label");
    String label = labelElement.getContent();

    // Make a Bubble object out of the data read
    bubbles[i] = new Bubble(x, y, diameter, label);
  }  
}

void draw() {
  background(255);
  // Display all bubbles
  for (int i = 0; i < bubbles.length; i++) {
    bubbles[i].display();
    bubbles[i].rollover(mouseX, mouseY);
  }
}

In addition to loadXML(), Processing also includes a saveXML() function for writing XML files to your sketch folder. You can modify the XML tree itself by adding or removing elements with addChild() or removeChild(), as well as modify the content of elements or attributes with setContent(), setIntContent(), setFloatContent(), setString(), setInt(), and setFloat().

JSON

Another increasingly popular data exchange format is JSON (pronounced like the name Jason), which stands for JavaScript Object Notation. Its design was based on the syntax for objects in the JavaScript programming language (and is most commonly used to pass data between web applications) but has become rather ubiquitous and language-agnostic. While you don't need to know anything about JavaScript to work in Processing, it won't hurt to get a sense of some basic JavaScript syntax while learning it.

JSON is an alternative to XML and the data can be looked at in a similarly tree-like manner. All JSON data comes in the following two ways: an object or an array. Luckily, you already know about these two concepts and only need to learn a new syntax for encoding them.

Let's take a look at a JSON object first. A JSON object is like a Processing object only with no functions. It’s simply a collection of variables with a name and a value (or "name/value pair"). For example, following is JSON data describing a person:

{
  "name":"Olympia",
  // Each name/value pair is separated by a comma.
  "age":3,
  "height":96.5,
  "state":"giggling"
}

Notice how this maps closely to classes in Processing.

class Person {
  String name;
  int age;
  float height;
  String state;
}

There are no classes in JSON, only the object literals themselves. Also an object can contain, as part of itself, another object.

{
  "name":"Olympia",
  "age":3,
  "height":96.5,
  "state":"giggling",
  // The value of “brother” is an object containing two name/value pairs.
  "brother":{
    "name":"Elias",
    "age":6
  }
}

In XML, the preceding JSON data would look like the following (for simplicity I'm avoiding the use of XML attributes).

<xml version="1.0" encoding="UTF-8"?>
<person>
  <name>Olympia</name>
  <age>3</age>
  <height>96.5</height>
  <state>giggling</state>
  <brother>
    <name>Elias</name>
    <age>6</age>
  </brother>
</person>

Multiple JSON objects can appear in the data as an array. Just like the arrays you use in Processing, a JSON array is simply a list of values (primitives or objects). The syntax, however, is different with square brackets indicating the use of an array rather than curly ones. Here is a simple JSON array of integers:

[1, 7, 8, 9, 10, 13, 15]

You might find an array as part of an object.

{
  "name":"Olympia",
  // The value of “favorite colors” is an array of strings.
  "favorite colors":[
    "purple",
    "blue",
    "pink"
  ]
}

Or an array of objects themselves. For example, here is what the bubbles would look like in JSON. Notice how this JSON data is organized as a single JSON object "bubbles," which contains a JSON array of JSON objects, the bubbles. Flip back to compare to the CSV and XML versions of the same data.

{
  "bubbles":[
    {
      "position":{
        "x":160,
        "y":103
      },
      "diameter":43.19838,
      "label":"Happy"
    },
    {
      "position":{
        "x":372,
        "y":137
      },
      "diameter":52.42526,
      "label":"Sad"
    },
    {
      "position":{
        "x":273,
        "y":235
      },
      "diameter":61.14072,
      "label":"Joyous"
    }
  ]
}

JSONObject and JSONArray

Now that I've covered the syntax of JSON, I can look at using the data in Processing. One thing that can be a bit tricky about working with JSON in Processing is that I have to treat objects and arrays differently. With XML, I simply had a single XML class with all the parsing functionality I needed. With JSON, I have two classes: JSONObject and JSONArray, and I'll have to be conscientious about picking which class I am using during the parsing process.

The first step is simply loading the data with either loadJSONObject() or loadJSONArray(). But which one? I have to look and see what is at the root of the JSON file, an object or array. This can be a little tricky. Let's look at these two JSON examples:

Sample 1:

[
  {
    "name":"Elias"
  },
  {
    "name":"Olympia"
  }
]

Sample 2:

{
  "names":[
    {
      "name":"Elias"
    },
    {
      "name":"Olympia"
    }
  ]
}

Look how similar the above two samples look. They both contain exactly the same data, two names "Elias" and "Olympia." There is one, very key difference, however, to how the data is formatted: the very first character. Is it a "[" or a "{"? The answer will determine whether you’re loading an array ("[") or an object("{"). JSON objects start with a curly bracket, while JSON arrays start with a square bracket.

JSONObject json = loadJSONObject("file.json");

JSONArray json = JSONArray("file.json");

Typically, even if the data is ultimately organized as an array of objects (such as the array of "bubble" objects), the root element of the JSON data will be an object that contains that array. Let's look at the bubble data one more time.

{
  "bubbles":[
    {
      "position":{
        "x":160,
        "y":103
      },
      "diameter":43.19838,
      "label":"Happy"
    },
    {
      "position":{
        "x":372,
        "y":137
      },
      "diameter":52.42526,
      "label":"Sad"
    }
  ]
}

With the above, I first load an object and then pull the array out of that object.

JSONObject json = loadJSONObject("data.json");
JSONArray bubbleData = json.getJSONArray("bubbles");

Just as with XML, the data from an element is accessed via its name, in this case "bubbles." With a JSONArray, however, each element of the array is retrieved via its numeric index. The following code iterates over a JSONArray.

for (int i = 0; i < bubbleData.size(); i++) {
  JSONObject bubble = bubbleData.getJSONObject(i);
 }

And when you're looking for a specific piece of data from a JSONObject, such as an integer or string, the functions are identical to those of XML attributes. The following code gets the position object from the bubble object, then gets x and y as integers from the position object. The diameter and label are then available directly from the Bubble object.

  JSONObject position = bubble.getJSONObject("position");


  int x = position.getInt("x");
  int y = position.getInt("y");

  float diameter = bubble.getFloat("diameter");
  String label = bubble.getString("label");

Putting this all together, I can now make a JSON version of the bubbles example (leaving out the draw() function and Bubble class which haven't changed.)

Using Processing's JSON Classes

// An Array of Bubble objects
Bubble[] bubbles;

void setup() {
  size(480, 360);
  loadData();
}

void loadData() {
  // Load the JSON file and grab the array.
  JSONObject json = loadJSONObject("data.json");
  JSONArray bubbleData = json.getJSONArray("bubbles");

  // The size of the array of Bubble objects is determined by the length of the JSON array.
  bubbles = new Bubble[bubbleData.size()]; 


  for (int i = 0; i<bubbleData.size(); i++) {

    // Iterate through the array, grabbing each JSON object one at a time.
    JSONObject bubble = bubbleData.getJSONObject(i);

    // Get a position object
    JSONObject position = bubble.getJSONObject("position");
    // Get (x,y) from JSON object "position"
    int x = position.getInt("x");
    int y = position.getInt("y");
    
    // Get diamter and label
    float diameter = bubble.getFloat("diameter");
    String label = bubble.getString("label");

    // Put the Bubble objects into an array.
    bubbles[i] = new Bubble(x, y, diameter, label);
  }
}

Threads

As you have seen, the various loading functions — loadStrings(), loadTable(), loadXML(), and loadJSONObject() — can be used for retrieving data from URLs. Nonetheless, unless your sketch only needs to load the data once during setup(), you may have a problem. For example, consider a sketch that grabs the price of AAPL stock from an XML feed every five minutes. Each time loadXML() is called, the sketch will pause while waiting to receive the data. Any animation will stutter. This is because these loading functions are “blocking.” In other words, the sketch will sit and wait at that line of code until loadXML() completes its task. With a local data file, this is extremely fast. Nonetheless, a request for a URL (known as an “HTTP request”) in Processing is synchronous, meaning your sketch waits for a response from the server before continuing. Who knows how will that take? No one; you are at the mercy of the server!

The answer to this problem lies in the concept of threads. By now you are quite familiar with the idea of writing a program that follows a specific sequence of steps — setup() first then draw() over and over and over again! A thread is also a series of steps with a beginning, a middle, and an end. A Processing sketch is a single thread, often referred to as the animation thread. Other threads’ sequences, however, can run independently of the main animation loop. In fact, you can launch any number of threads at one time, and they will all run concurrently.

Processing does this quite often, such as with library functions like captureEvent() and movieEvent(). These functions are triggered by a different thread running behind the scenes, and they alert Processing whenever they have something to report. This is useful when you need to perform a task that takes too long and would slow down the main animation's frame rate, such as grabbing data from the network. Here, you want to handle the request asynchronously in a different thread. If that thread gets stuck or has an error, the entire program won't grind to a halt, since the error only stops that individual thread and not the main animation loop.

Writing your own thread can be a complex endeavor that involves extending the Java Thread class. However, the thread() method is a quick and dirty way to implement a simple thread in Processing. By passing in a string that matches the name of a function declared elsewhere in the sketch, Processing will execute that function in a separate thread. Let's take a look at a skeleton of how this works.

void setup() {
  thread("someFunction");
}
 
void draw() {
 
}
 
void someFunction() {
  // This function will run as a thread when called via
  // thread("someFunction") as it was in setup!
}

The thread() function receives a string as an argument. The string should match the name of the function you want to run as a thread. In the above example it’s "someFunction".

Let's look at a more practical example. For an example of data that changes often, I'll use time.jsontest.com which gives you the current time (in milliseconds). While I could retrieve this from the system clock, this works well for demonstrating continuously requesting data that changes over time. Not knowing about threads, my first instinct might be to say:

void draw() {
  // The code will stop here and wait to receive the data before moving on.
  JSONObject json = loadJSONObject("http://time.jsontest.com/");
  String time = json.getString("time");
  text(time, 40, 100);
}

This would give me the current time every cycle through draw(). If I examine the frame rate, however, I'll notice that the sketch is running incredibly slowly (and all it needs to do is draw a single string!). This is where calling the parsing code as a separate thread will help a lot.

String time = "";

void draw() {
  // Now the code will move on to the next line while requestData() executes in a separate thread.
  thread("requestData");
  text(time, 40, 100);
}

void requestData() {
  JSONObject json = loadJSONObject("http://time.jsontest.com/");
  time = json.getString("time");
}

The logic is identical, only I am not requesting the data directly in draw(), but executing that request as a separate thread. Notice that I am not doing any drawing in requestData(). This is key as executing drawing functions in code that runs on a separate thread can cause conflicts with the main animation thread (i.e., draw()) resulting in strange behavior and errors.

In the above example, I likely don't want to request the data sixty times per second (the default frame rate). Instead I might make use of the Timer class, and ask for the data once per second. Here is a full example that does exactly that with added animation to show that draw() never stutters.
Threads

Timer timer = new Timer(1000);
String time = "";

void setup() {
  size(200, 200);
  // Start by requesting the data asynchronously in a thread.
  thread("retrieveData");
  timer.start();
}

void draw() {
  background(255);
  // Every one second, make a new request.
  if (timer.isFinished()) {
    retrieveData();
  
  // And restart the timer.
    timer.start();
  }

  fill(0);
  text(time, 40, 100);

  translate(20, 100);
  stroke(0);
  //Draw a little animation to demonstrate that the draw() loop never pauses.
  rotate(frameCount*0.04);
  for (int i = 0; i<10; i++) {
    rotate(radians(36));
    line(5, 0, 10, 0);
  }
}

// get the data
void retrieveData() {
  JSONObject json = loadJSONObject("http://time.jsontest.com/");
  time = json.getString("time");
}

APIs

It’s a bit silly for me to call this section “APIs” given that most of this chapter is about data from APIs. Still, it’s worth taking a moment to pause and reflect. What makes something an API versus just some data you found, and what are some pitfalls you might run into when using an API?

As I've stated, an API (Application Programming Interface) is an interface through which one application can access the services of another. These can come in many forms. Openweathermap.org, as you saw earlier, is an API that offers its data in JSON, XML, and HTML formats. The key element that makes this service an API is exactly that offer; openweathermap.org's sole purpose in life is to offer you its data. And not just offer it, but allow you to query it for specific data in a specific format. Let's look at a short list of sample queries.

http://api.openweathermap.org/data/2.5/weather?lat=35&lon=139
    A request for current weather data for a specific latitude and longitude.
http://api.openweathermap.org/data/2.5/forecast/daily?q=London&mode=xml&units=metric&cnt=7&lang=zh_cn
    A request for a seven day London forecast in XML format with metric units and in Chinese.
http://api.openweathermap.org/data/2.5/history/station?id=5091&type=day
    A request for a historical data for a given weather station.

One thing to note about openweathermap.org is that it does not require that you tell the API any information about yourself. You simply send a request to a URL and get the data back. Other APIs, however, require you to sign up and obtain an access token. The New York Times API is one such example. Before you can make a request from Processing, you'll need to visit The New York Times Developer site and request an API key. Once you have that key, you can store it in your code as a string.

// This is not a real key
String apiKey = "40e2es0b3ca44563f9c62aeded4431dc:12:51913116";

You also need to know what the URL is for the API itself. This information is documented for you on the developer site, but here it is for simplicity:

String url = "http://api.nytimes.com/svc/search/v2/articlesearch.json";

Finally, you have to tell the API what it is you are looking for. This is done with a “query string,” a sequence of name value pairs describing the parameters of the query joined with an ampersand. This functions similarly to how you pass arguments to a function in Processing. If you wanted to search for the term "processing" from a search() function you might say:

search("processing");

Here, the API acts as the function call, and you send it the arguments via the query string. Here is a simple example asking for a list of the oldest articles that contain the term "processing" (the oldest of which turns out to be May 12th, 1852).

// The name/value pairs that configure the API query are: (q,processing) and (sort,oldest)
String query = "?q=processing&sort=oldest";

This isn't just guesswork. Figuring out how to put together a query string requires reading through the API's documentation. For The New York Times, it’s all outlined on the Times' developer website. Once you have your query you can join all the pieces together and pass it to loadJSONObject(). Here is a tiny example that simply displays the most recent headline.

NYTimes API Query

void setup() {
  size(200, 200);
  
  String apiKey = "40e2ea0b3ca44563f9c62aeded0431dc:18:51513116";
  String url = "http://api.nytimes.com/svc/search/v2/articlesearch.json";
  String query = "?q=processing&sort=newest";

  // Make the API query
  // Here, I format the call to the API by joing the URL with the API key with the query string.
  JSONObject json = loadJSONObject(url+query+"&api-key="+apiKey);

  String headline = json.getJSONObject("response").getJSONArray("docs").
    // Grabbing a single headline from the results.
    getJSONObject(0).getJSONObject("headline").getString("main");
  background(255);
  fill(0);
  text(headline, 10, 10, 180, 190);
}

Some APIs require a deeper level of authentication beyond an API access key. Twitter, for example, uses an authentication protocol known as “OAuth” to provide access to its data. Writing an OAuth application requires more than just passing a String into a request and is beyond the scope of this tutorial. However, in these cases, if you’re lucky, you can find a Processing library that handles all of the authentication for you. There are several APIs that can be used directly with Processing via a library, and you can find a list of them in the “Data / Protocols” section of the libraires reference page for some ideas. Temboo, for example, offers a Processing library that handles OAuth for you and provides direct access to many APIs (including Twitter) in Processing. With Temboo, you can write code that looks like:

// Temboo acts as a go-between you and Twitter, so first you just authenticate with Temboo.
TembooSession session = new TembooSession("ACCOUNT_NAME", "APP_NAME", "APP_KEY");

Tweets tweets = new Tweets(session);
// Then you can configure a query to send to Twitter itself and grab the results.
tweets.setCredential("your-twitter-name");
tweetsChoreo.setQuery("arugula");
TweetsResultSet tweetsResults = tweets.run();

JSONObject searchResults = parseJSONObject(tweetsResults.getResponse());

JSONArray statuses = searchResults.getJSONArray("statuses");

// Finally, you can search through the results and grab a tweet.
JSONObject tweet = statuses.getJSONObject(0);
String tweetText = tweet.getString("text"); 

Processing was initiated by Ben Fry and Casey Reas. It is developed by a small team of volunteers.
© Info

